#  1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен
# принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Примеры матриц вы найдете в методичке.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix (двух матриц).
# Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с первым
# элементом первой строки второй матрицы и т.д.

class Matrix():
    def __init__(self, x , y, z):
        self.x = x[0], x[1] , x[2]
        self.y = y[0], y[1] , y[2]
        self.z = z[0], z[1] , z[2]
        
    def __str__(self):
        return str(self.x) + "\n" + str(self.y) + "\n" + str(self.z) 
    
    def __add__(self, other):
        return  Matrix((self.x[0] + other.x[0], self.x[1] + other.x[1], self.x[2] + other.x[2]),
                       (self.y[0] + other.y[0], self.y[1] + other.y[1], self.y[2] + other.y[2]),
                       (self.z[0] + other.z[0], self.z[1] + other.z[1], self.z[2] + other.z[2]))
      
#Проверка
first_matrix = Matrix((1,1,1), (2,2,2), (3,3,3))
second_matrix = Matrix((1,1,1), (2,2,2), (3,3,3))

print(first_matrix + second_matrix)

# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого проекта — 
# одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм. У этих типов
# одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5), для костюма (2 * H + 0.3)
# Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные
# классы для основных классов проекта, проверить на практике работу декоратора @property.

from abc import ABC, abstractmethod

class Clothes(ABC):
        
    @abstractmethod
    def parameters(self, X):
        self.X = X


class Coat(Clothes):
    def parameters(self, X):
        self.X = X
        print(f"Для пальто задан параметр Размер: {self.X}")
    
    @property
    def costs(self):
        costs = self.X/6.5 + 0.5
        print(f"Расход ткани для одного пальто равен: {costs} ")
        
class Suit(Clothes):
    def parameters(self, X):
        self.X = X
        print(f'Для костюма задан параметр Рост: {self.X}')
        
    @property
    def costs(self):
        costs = 2 * self.X + 0.3
        print(f"Расход ткани для одного костюма равен: {costs} ")
 
#Проверка
example = Suit()
example.parameters(2.5)
example.costs

# 3. Реализовать программу работы с органическими клетками. Необходимо создать класс Клетка. В его конструкторе инициализировать
# параметр, соответствующий количеству клеток (целое число). В классе должны быть реализованы методы перегрузки арифметических
# операторов: сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).Данные методы должны
# применяться только к клеткам и выполнять увеличение, уменьшение, умножение и обычное (не целочисленное) деление клеток, 
# соответственно. В методе деления должно осуществляться округление значения до целого числа.

#Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно равняться сумме ячеек исходных двух клеток.
#Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек двух клеток больше нуля,
#иначе выводить соответствующее сообщение.
#Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек этих двух
#клеток.
#Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих
#двух клеток.
#В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. Данный метод
#позволяет организовать ячейки по рядам.
#Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если
#ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
#Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку:
#*****\n*****\n**.
#Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order() вернет строку:
#*****\n*****\n*****.

class Cell(int):
    
    def __new__(cls, str):
        return int.__new__(cls, str)
    
    def __init__(self, x):
        self.x = x
        
    def make_order(self, n):
        if self.x > n:
            w_part = self.x // n
            f_part = self.x % n
            string = ('*' * n + r'\n') * w_part + '*' * f_part
            print(string)
        else:
            print('*' * self.x) 
            
    def __add__(self, other):
        new = self.x + other.x
        print ('*' * new)
        
    def __sub__(self, other):
        if self.x >= other.x:
            new = self.x - other.x
            print ('*' * new)
        else: 
            print("Ошибка. Операция не может быть выполнена")
            
    def __mul__(self, other):
        new = self.x * other.x
        print ('*' * new)

    def __truediv__(self, other):
        new = self.x / other.x
        print ('*' * round(new))
        
#Проверка
first_cell = Cell(5)
second_cell = Cell(2)

first_cell.make_order(7)
first_cell + second_cell
first_cell - second_cell
second_cell - first_cell
second_cell * first_cell
first_cell / second_cell
